# PropertyTracker v0.1 Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build the minimum viable product - bank feeds → categorize transactions → CSV export for accountant.

**Architecture:** Next.js 16 App Router with tRPC for type-safe API, Clerk for auth, Drizzle ORM with Supabase PostgreSQL, Basiq for Australian bank feeds. Forest theme (green primary) with CSS variable theming system.

**Tech Stack:** Next.js 16, tRPC, Drizzle ORM, PostgreSQL (Supabase), Clerk, Basiq, Tailwind CSS, shadcn/ui

**Timeline:** 4 weeks (Kill criteria: if not shipped in 4 weeks, stop)

---

## Phase 1: Project Setup (Day 1-2)

### Task 1: Initialize Next.js Project

**Files:**
- Create: `package.json`
- Create: `next.config.js`
- Create: `tsconfig.json`
- Create: `.env.local.example`

**Step 1: Create Next.js project**

```bash
cd /Users/matthewgleeson/Documents/new-project/.worktrees/v0.1-mvp
npx create-next-app@latest . --typescript --tailwind --eslint --app --src-dir --import-alias "@/*"
```

Select:
- Would you like to use TypeScript? Yes
- Would you like to use ESLint? Yes
- Would you like to use Tailwind CSS? Yes
- Would you like to use `src/` directory? Yes
- Would you like to use App Router? Yes
- Would you like to customize the default import alias? Yes → @/*

**Step 2: Verify project runs**

```bash
npm run dev
```

Expected: Server starts at http://localhost:3000

**Step 3: Commit**

```bash
git add -A
git commit -m "feat: initialize Next.js 16 project with TypeScript and Tailwind"
```

---

### Task 2: Install Core Dependencies

**Files:**
- Modify: `package.json`

**Step 1: Install dependencies**

```bash
npm install @clerk/nextjs @tanstack/react-query @trpc/client @trpc/server @trpc/react-query @trpc/next zod drizzle-orm postgres react-hook-form @hookform/resolvers lucide-react date-fns
npm install -D drizzle-kit @types/node
```

**Step 2: Install shadcn/ui**

```bash
npx shadcn@latest init
```

Select:
- Style: Default
- Base color: Neutral
- CSS variables: Yes

**Step 3: Add shadcn components**

```bash
npx shadcn@latest add button card input label select table dropdown-menu dialog toast form checkbox badge separator
```

**Step 4: Commit**

```bash
git add -A
git commit -m "feat: add core dependencies (tRPC, Drizzle, Clerk, shadcn)"
```

---

### Task 3: Setup Environment Variables

**Files:**
- Create: `.env.local.example`
- Create: `.env.local` (gitignored)

**Step 1: Create example env file**

Create `.env.local.example`:

```env
# Clerk
NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=pk_test_...
CLERK_SECRET_KEY=sk_test_...
NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/dashboard
NEXT_PUBLIC_CLERK_AFTER_SIGN_UP_URL=/dashboard

# Database (Supabase)
DATABASE_URL=postgresql://postgres:password@db.xxx.supabase.co:5432/postgres

# Basiq
BASIQ_API_KEY=your_basiq_api_key
BASIQ_SERVER_URL=https://au-api.basiq.io

# App
NEXT_PUBLIC_APP_URL=http://localhost:3000
```

**Step 2: Add .env.local to gitignore**

Verify `.gitignore` contains:
```
.env*.local
```

**Step 3: Commit**

```bash
git add .env.local.example .gitignore
git commit -m "feat: add environment variable template"
```

---

### Task 4: Setup Forest Theme System

**Files:**
- Create: `src/styles/themes.css`
- Modify: `src/app/globals.css`
- Modify: `tailwind.config.ts`

**Step 1: Create themes CSS file**

Create `src/styles/themes.css`:

```css
/* Default Theme: Forest (Green) */
:root {
  /* Primary brand colors */
  --color-primary: #16A34A;
  --color-primary-hover: #15803D;
  --color-primary-light: #DCFCE7;
  --color-primary-foreground: #FFFFFF;

  /* Semantic colors */
  --color-success: #10B981;
  --color-warning: #F59E0B;
  --color-danger: #EF4444;
  --color-info: #3B82F6;

  /* Backgrounds */
  --bg-primary: #FFFFFF;
  --bg-secondary: #F0FDF4;
  --bg-tertiary: #DCFCE7;
  --bg-card: #FFFFFF;

  /* Text */
  --text-primary: #14532D;
  --text-secondary: #166534;
  --text-muted: #4ADE80;
  --text-inverse: #FFFFFF;

  /* Borders */
  --border-light: #BBF7D0;
  --border-medium: #86EFAC;

  /* Shadows */
  --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
  --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.1);
  --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.1);

  /* Radius */
  --radius-sm: 0.375rem;
  --radius-md: 0.5rem;
  --radius-lg: 0.75rem;
  --radius-xl: 1rem;
}

/* Clean Theme (Blue) */
[data-theme="clean"] {
  --color-primary: #0066CC;
  --color-primary-hover: #0052A3;
  --color-primary-light: #E6F0FF;
  --color-primary-foreground: #FFFFFF;
  --bg-primary: #FFFFFF;
  --bg-secondary: #F9FAFB;
  --bg-tertiary: #F3F4F6;
  --bg-card: #FFFFFF;
  --text-primary: #111827;
  --text-secondary: #6B7280;
  --text-muted: #9CA3AF;
  --border-light: #E5E7EB;
  --border-medium: #D1D5DB;
}

/* Dark Theme */
[data-theme="dark"] {
  --color-primary: #3B82F6;
  --color-primary-hover: #2563EB;
  --color-primary-light: #1E3A5F;
  --color-primary-foreground: #FFFFFF;
  --bg-primary: #0F172A;
  --bg-secondary: #1E293B;
  --bg-tertiary: #334155;
  --bg-card: #1E293B;
  --text-primary: #F8FAFC;
  --text-secondary: #94A3B8;
  --text-muted: #64748B;
  --border-light: #334155;
  --border-medium: #475569;
  --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.4);
}

/* Friendly Theme */
[data-theme="friendly"] {
  --color-primary: #059669;
  --color-primary-hover: #047857;
  --color-primary-light: #D1FAE5;
  --color-primary-foreground: #FFFFFF;
  --bg-primary: #FAFAF9;
  --bg-secondary: #F5F5F4;
  --bg-tertiary: #E7E5E4;
  --bg-card: #FFFFFF;
  --text-primary: #1C1917;
  --text-secondary: #78716C;
  --text-muted: #A8A29E;
  --border-light: #E7E5E4;
  --border-medium: #D6D3D1;
  --radius-sm: 0.5rem;
  --radius-md: 1rem;
  --radius-lg: 1.5rem;
}

/* Bold Theme */
[data-theme="bold"] {
  --color-primary: #1D4ED8;
  --color-primary-hover: #1E40AF;
  --color-primary-light: #DBEAFE;
  --color-primary-foreground: #FFFFFF;
  --bg-primary: #F8FAFC;
  --bg-secondary: #F1F5F9;
  --bg-tertiary: #E2E8F0;
  --bg-card: #FFFFFF;
  --text-primary: #0F172A;
  --text-secondary: #475569;
  --text-muted: #94A3B8;
  --border-light: #CBD5E1;
  --border-medium: #94A3B8;
  --radius-sm: 0.125rem;
  --radius-md: 0.25rem;
  --radius-lg: 0.375rem;
}
```

**Step 2: Update globals.css**

Replace `src/app/globals.css`:

```css
@import './styles/themes.css';
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-primary text-primary;
    background-color: var(--bg-primary);
    color: var(--text-primary);
  }
}

/* Override shadcn defaults with theme variables */
@layer base {
  :root {
    --background: var(--bg-primary);
    --foreground: var(--text-primary);
    --card: var(--bg-card);
    --card-foreground: var(--text-primary);
    --primary: var(--color-primary);
    --primary-foreground: var(--color-primary-foreground);
    --secondary: var(--bg-secondary);
    --secondary-foreground: var(--text-primary);
    --muted: var(--bg-tertiary);
    --muted-foreground: var(--text-muted);
    --accent: var(--color-primary-light);
    --accent-foreground: var(--text-primary);
    --destructive: var(--color-danger);
    --destructive-foreground: #FFFFFF;
    --border: var(--border-light);
    --input: var(--border-light);
    --ring: var(--color-primary);
    --radius: var(--radius-md);
  }
}
```

**Step 3: Update Tailwind config**

Replace `tailwind.config.ts`:

```typescript
import type { Config } from "tailwindcss";

const config: Config = {
  darkMode: ["class"],
  content: [
    "./src/pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/components/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    extend: {
      colors: {
        border: "var(--border-light)",
        input: "var(--border-light)",
        ring: "var(--color-primary)",
        background: "var(--bg-primary)",
        foreground: "var(--text-primary)",
        primary: {
          DEFAULT: "var(--color-primary)",
          foreground: "var(--color-primary-foreground)",
          hover: "var(--color-primary-hover)",
          light: "var(--color-primary-light)",
        },
        secondary: {
          DEFAULT: "var(--bg-secondary)",
          foreground: "var(--text-primary)",
        },
        success: "var(--color-success)",
        warning: "var(--color-warning)",
        danger: "var(--color-danger)",
        muted: {
          DEFAULT: "var(--bg-tertiary)",
          foreground: "var(--text-muted)",
        },
        card: {
          DEFAULT: "var(--bg-card)",
          foreground: "var(--text-primary)",
        },
      },
      borderRadius: {
        sm: "var(--radius-sm)",
        md: "var(--radius-md)",
        lg: "var(--radius-lg)",
        xl: "var(--radius-xl)",
      },
      boxShadow: {
        sm: "var(--shadow-sm)",
        md: "var(--shadow-md)",
        lg: "var(--shadow-lg)",
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
};

export default config;
```

**Step 4: Commit**

```bash
git add -A
git commit -m "feat: add Forest theme system with CSS variables"
```

---

### Task 5: Setup Clerk Authentication

**Files:**
- Create: `src/middleware.ts`
- Create: `src/app/(auth)/sign-in/[[...sign-in]]/page.tsx`
- Create: `src/app/(auth)/sign-up/[[...sign-up]]/page.tsx`
- Modify: `src/app/layout.tsx`

**Step 1: Create middleware**

Create `src/middleware.ts`:

```typescript
import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";

const isPublicRoute = createRouteMatcher([
  "/",
  "/sign-in(.*)",
  "/sign-up(.*)",
  "/api/webhooks(.*)",
]);

export default clerkMiddleware(async (auth, req) => {
  if (!isPublicRoute(req)) {
    await auth.protect();
  }
});

export const config = {
  matcher: ["/((?!.*\\..*|_next).*)", "/", "/(api|trpc)(.*)"],
};
```

**Step 2: Create sign-in page**

Create `src/app/(auth)/sign-in/[[...sign-in]]/page.tsx`:

```typescript
import { SignIn } from "@clerk/nextjs";

export default function SignInPage() {
  return (
    <div className="flex min-h-screen items-center justify-center bg-secondary">
      <SignIn
        appearance={{
          elements: {
            formButtonPrimary: "bg-primary hover:bg-primary-hover",
            card: "shadow-lg",
          },
        }}
      />
    </div>
  );
}
```

**Step 3: Create sign-up page**

Create `src/app/(auth)/sign-up/[[...sign-up]]/page.tsx`:

```typescript
import { SignUp } from "@clerk/nextjs";

export default function SignUpPage() {
  return (
    <div className="flex min-h-screen items-center justify-center bg-secondary">
      <SignUp
        appearance={{
          elements: {
            formButtonPrimary: "bg-primary hover:bg-primary-hover",
            card: "shadow-lg",
          },
        }}
      />
    </div>
  );
}
```

**Step 4: Update root layout**

Replace `src/app/layout.tsx`:

```typescript
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import { ClerkProvider } from "@clerk/nextjs";
import "./globals.css";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "PropertyTracker - Australian Property Investment Tracking",
  description: "Track your investment properties, automate bank feeds, and generate tax reports.",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <ClerkProvider>
      <html lang="en">
        <body className={inter.className}>{children}</body>
      </html>
    </ClerkProvider>
  );
}
```

**Step 5: Commit**

```bash
git add -A
git commit -m "feat: setup Clerk authentication with sign-in/sign-up pages"
```

---

### Task 6: Setup Database Schema

**Files:**
- Create: `src/server/db/schema.ts`
- Create: `src/server/db/index.ts`
- Create: `drizzle.config.ts`

**Step 1: Create database schema**

Create `src/server/db/schema.ts`:

```typescript
import {
  pgTable,
  uuid,
  text,
  timestamp,
  decimal,
  date,
  boolean,
  pgEnum,
} from "drizzle-orm/pg-core";

// Enums
export const stateEnum = pgEnum("state", [
  "NSW",
  "VIC",
  "QLD",
  "SA",
  "WA",
  "TAS",
  "NT",
  "ACT",
]);

export const accountTypeEnum = pgEnum("account_type", [
  "transaction",
  "savings",
  "mortgage",
  "offset",
  "credit_card",
  "line_of_credit",
]);

export const categoryEnum = pgEnum("category", [
  // Income
  "rental_income",
  "other_rental_income",
  // Expenses (Deductible)
  "advertising",
  "body_corporate",
  "borrowing_expenses",
  "cleaning",
  "council_rates",
  "gardening",
  "insurance",
  "interest_on_loans",
  "land_tax",
  "legal_expenses",
  "pest_control",
  "property_agent_fees",
  "repairs_and_maintenance",
  "capital_works_deductions",
  "stationery_and_postage",
  "travel_expenses",
  "water_charges",
  "sundry_rental_expenses",
  // Capital (CGT)
  "stamp_duty",
  "conveyancing",
  "buyers_agent_fees",
  "initial_repairs",
  // Other
  "transfer",
  "personal",
  "uncategorized",
]);

export const transactionTypeEnum = pgEnum("transaction_type", [
  "income",
  "expense",
  "capital",
  "transfer",
  "personal",
]);

// Tables
export const users = pgTable("users", {
  id: uuid("id").primaryKey().defaultRandom(),
  clerkId: text("clerk_id").notNull().unique(),
  email: text("email").notNull().unique(),
  name: text("name"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const properties = pgTable("properties", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: uuid("user_id")
    .references(() => users.id, { onDelete: "cascade" })
    .notNull(),
  address: text("address").notNull(),
  suburb: text("suburb").notNull(),
  state: stateEnum("state").notNull(),
  postcode: text("postcode").notNull(),
  purchasePrice: decimal("purchase_price", { precision: 12, scale: 2 }).notNull(),
  purchaseDate: date("purchase_date").notNull(),
  entityName: text("entity_name").default("Personal").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const bankAccounts = pgTable("bank_accounts", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: uuid("user_id")
    .references(() => users.id, { onDelete: "cascade" })
    .notNull(),
  basiqConnectionId: text("basiq_connection_id").notNull(),
  basiqAccountId: text("basiq_account_id").notNull().unique(),
  institution: text("institution").notNull(),
  accountName: text("account_name").notNull(),
  accountNumberMasked: text("account_number_masked"),
  accountType: accountTypeEnum("account_type").notNull(),
  defaultPropertyId: uuid("default_property_id").references(() => properties.id, {
    onDelete: "set null",
  }),
  isConnected: boolean("is_connected").default(true).notNull(),
  lastSyncedAt: timestamp("last_synced_at"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export const transactions = pgTable("transactions", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: uuid("user_id")
    .references(() => users.id, { onDelete: "cascade" })
    .notNull(),
  bankAccountId: uuid("bank_account_id")
    .references(() => bankAccounts.id, { onDelete: "cascade" })
    .notNull(),
  basiqTransactionId: text("basiq_transaction_id").unique(),
  propertyId: uuid("property_id").references(() => properties.id, {
    onDelete: "set null",
  }),
  date: date("date").notNull(),
  description: text("description").notNull(),
  amount: decimal("amount", { precision: 12, scale: 2 }).notNull(),
  category: categoryEnum("category").default("uncategorized").notNull(),
  transactionType: transactionTypeEnum("transaction_type").default("expense").notNull(),
  isDeductible: boolean("is_deductible").default(false).notNull(),
  isVerified: boolean("is_verified").default(false).notNull(),
  notes: text("notes"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

// Type exports
export type User = typeof users.$inferSelect;
export type NewUser = typeof users.$inferInsert;
export type Property = typeof properties.$inferSelect;
export type NewProperty = typeof properties.$inferInsert;
export type BankAccount = typeof bankAccounts.$inferSelect;
export type NewBankAccount = typeof bankAccounts.$inferInsert;
export type Transaction = typeof transactions.$inferSelect;
export type NewTransaction = typeof transactions.$inferInsert;
```

**Step 2: Create database connection**

Create `src/server/db/index.ts`:

```typescript
import { drizzle } from "drizzle-orm/postgres-js";
import postgres from "postgres";
import * as schema from "./schema";

const connectionString = process.env.DATABASE_URL!;

const client = postgres(connectionString, { prepare: false });

export const db = drizzle(client, { schema });
```

**Step 3: Create Drizzle config**

Create `drizzle.config.ts`:

```typescript
import type { Config } from "drizzle-kit";

export default {
  schema: "./src/server/db/schema.ts",
  out: "./drizzle",
  dialect: "postgresql",
  dbCredentials: {
    url: process.env.DATABASE_URL!,
  },
} satisfies Config;
```

**Step 4: Add database scripts to package.json**

Add to `package.json` scripts:

```json
{
  "scripts": {
    "db:generate": "drizzle-kit generate",
    "db:migrate": "drizzle-kit migrate",
    "db:push": "drizzle-kit push",
    "db:studio": "drizzle-kit studio"
  }
}
```

**Step 5: Commit**

```bash
git add -A
git commit -m "feat: add database schema with Drizzle ORM"
```

---

### Task 7: Setup tRPC

**Files:**
- Create: `src/server/trpc.ts`
- Create: `src/server/routers/_app.ts`
- Create: `src/server/routers/property.ts`
- Create: `src/server/routers/transaction.ts`
- Create: `src/server/routers/banking.ts`
- Create: `src/app/api/trpc/[trpc]/route.ts`
- Create: `src/lib/trpc/client.ts`
- Create: `src/lib/trpc/Provider.tsx`

**Step 1: Create tRPC server setup**

Create `src/server/trpc.ts`:

```typescript
import { initTRPC, TRPCError } from "@trpc/server";
import { auth } from "@clerk/nextjs/server";
import { db } from "./db";
import { users } from "./db/schema";
import { eq } from "drizzle-orm";

export const createTRPCContext = async () => {
  const { userId: clerkId } = await auth();

  return {
    db,
    clerkId,
  };
};

const t = initTRPC.context<typeof createTRPCContext>().create();

export const router = t.router;
export const publicProcedure = t.procedure;

export const protectedProcedure = t.procedure.use(async ({ ctx, next }) => {
  if (!ctx.clerkId) {
    throw new TRPCError({ code: "UNAUTHORIZED" });
  }

  // Get or create user in our database
  let user = await ctx.db.query.users.findFirst({
    where: eq(users.clerkId, ctx.clerkId),
  });

  if (!user) {
    // User will be created via webhook, but handle edge case
    throw new TRPCError({
      code: "UNAUTHORIZED",
      message: "User not found. Please sign out and sign in again.",
    });
  }

  return next({
    ctx: {
      ...ctx,
      user,
    },
  });
});
```

**Step 2: Create property router**

Create `src/server/routers/property.ts`:

```typescript
import { z } from "zod";
import { router, protectedProcedure } from "../trpc";
import { properties } from "../db/schema";
import { eq, and } from "drizzle-orm";

const propertySchema = z.object({
  address: z.string().min(1, "Address is required"),
  suburb: z.string().min(1, "Suburb is required"),
  state: z.enum(["NSW", "VIC", "QLD", "SA", "WA", "TAS", "NT", "ACT"]),
  postcode: z.string().regex(/^\d{4}$/, "Invalid postcode"),
  purchasePrice: z.string().regex(/^\d+\.?\d*$/, "Invalid price"),
  purchaseDate: z.string(),
  entityName: z.string().optional(),
});

export const propertyRouter = router({
  list: protectedProcedure.query(async ({ ctx }) => {
    return ctx.db.query.properties.findMany({
      where: eq(properties.userId, ctx.user.id),
      orderBy: (properties, { desc }) => [desc(properties.createdAt)],
    });
  }),

  get: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .query(async ({ ctx, input }) => {
      const property = await ctx.db.query.properties.findFirst({
        where: and(
          eq(properties.id, input.id),
          eq(properties.userId, ctx.user.id)
        ),
      });

      if (!property) {
        throw new Error("Property not found");
      }

      return property;
    }),

  create: protectedProcedure
    .input(propertySchema)
    .mutation(async ({ ctx, input }) => {
      const [property] = await ctx.db
        .insert(properties)
        .values({
          userId: ctx.user.id,
          address: input.address,
          suburb: input.suburb,
          state: input.state,
          postcode: input.postcode,
          purchasePrice: input.purchasePrice,
          purchaseDate: input.purchaseDate,
          entityName: input.entityName || "Personal",
        })
        .returning();

      return property;
    }),

  update: protectedProcedure
    .input(z.object({ id: z.string().uuid() }).merge(propertySchema.partial()))
    .mutation(async ({ ctx, input }) => {
      const { id, ...data } = input;

      const [property] = await ctx.db
        .update(properties)
        .set({
          ...data,
          updatedAt: new Date(),
        })
        .where(and(eq(properties.id, id), eq(properties.userId, ctx.user.id)))
        .returning();

      return property;
    }),

  delete: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      await ctx.db
        .delete(properties)
        .where(
          and(eq(properties.id, input.id), eq(properties.userId, ctx.user.id))
        );

      return { success: true };
    }),
});
```

**Step 3: Create transaction router**

Create `src/server/routers/transaction.ts`:

```typescript
import { z } from "zod";
import { router, protectedProcedure } from "../trpc";
import { transactions, properties, bankAccounts } from "../db/schema";
import { eq, and, desc, gte, lte, inArray } from "drizzle-orm";

const categoryValues = [
  "rental_income",
  "other_rental_income",
  "advertising",
  "body_corporate",
  "borrowing_expenses",
  "cleaning",
  "council_rates",
  "gardening",
  "insurance",
  "interest_on_loans",
  "land_tax",
  "legal_expenses",
  "pest_control",
  "property_agent_fees",
  "repairs_and_maintenance",
  "capital_works_deductions",
  "stationery_and_postage",
  "travel_expenses",
  "water_charges",
  "sundry_rental_expenses",
  "stamp_duty",
  "conveyancing",
  "buyers_agent_fees",
  "initial_repairs",
  "transfer",
  "personal",
  "uncategorized",
] as const;

export const transactionRouter = router({
  list: protectedProcedure
    .input(
      z.object({
        propertyId: z.string().uuid().optional(),
        category: z.enum(categoryValues).optional(),
        isVerified: z.boolean().optional(),
        startDate: z.string().optional(),
        endDate: z.string().optional(),
        limit: z.number().min(1).max(100).default(50),
        offset: z.number().min(0).default(0),
      })
    )
    .query(async ({ ctx, input }) => {
      const conditions = [eq(transactions.userId, ctx.user.id)];

      if (input.propertyId) {
        conditions.push(eq(transactions.propertyId, input.propertyId));
      }
      if (input.category) {
        conditions.push(eq(transactions.category, input.category));
      }
      if (input.isVerified !== undefined) {
        conditions.push(eq(transactions.isVerified, input.isVerified));
      }
      if (input.startDate) {
        conditions.push(gte(transactions.date, input.startDate));
      }
      if (input.endDate) {
        conditions.push(lte(transactions.date, input.endDate));
      }

      const results = await ctx.db.query.transactions.findMany({
        where: and(...conditions),
        orderBy: [desc(transactions.date)],
        limit: input.limit,
        offset: input.offset,
        with: {
          property: true,
          bankAccount: true,
        },
      });

      return results;
    }),

  updateCategory: protectedProcedure
    .input(
      z.object({
        id: z.string().uuid(),
        category: z.enum(categoryValues),
        propertyId: z.string().uuid().optional(),
      })
    )
    .mutation(async ({ ctx, input }) => {
      // Determine transaction type and deductibility based on category
      const incomeCategories = ["rental_income", "other_rental_income"];
      const capitalCategories = [
        "stamp_duty",
        "conveyancing",
        "buyers_agent_fees",
        "initial_repairs",
      ];
      const nonDeductibleCategories = [
        ...capitalCategories,
        "transfer",
        "personal",
        "uncategorized",
      ];

      let transactionType: "income" | "expense" | "capital" | "transfer" | "personal" =
        "expense";
      if (incomeCategories.includes(input.category)) {
        transactionType = "income";
      } else if (capitalCategories.includes(input.category)) {
        transactionType = "capital";
      } else if (input.category === "transfer") {
        transactionType = "transfer";
      } else if (input.category === "personal") {
        transactionType = "personal";
      }

      const isDeductible = !nonDeductibleCategories.includes(input.category);

      const [transaction] = await ctx.db
        .update(transactions)
        .set({
          category: input.category,
          transactionType,
          isDeductible,
          propertyId: input.propertyId,
          updatedAt: new Date(),
        })
        .where(
          and(eq(transactions.id, input.id), eq(transactions.userId, ctx.user.id))
        )
        .returning();

      return transaction;
    }),

  bulkUpdateCategory: protectedProcedure
    .input(
      z.object({
        ids: z.array(z.string().uuid()),
        category: z.enum(categoryValues),
        propertyId: z.string().uuid().optional(),
      })
    )
    .mutation(async ({ ctx, input }) => {
      const incomeCategories = ["rental_income", "other_rental_income"];
      const capitalCategories = [
        "stamp_duty",
        "conveyancing",
        "buyers_agent_fees",
        "initial_repairs",
      ];
      const nonDeductibleCategories = [
        ...capitalCategories,
        "transfer",
        "personal",
        "uncategorized",
      ];

      let transactionType: "income" | "expense" | "capital" | "transfer" | "personal" =
        "expense";
      if (incomeCategories.includes(input.category)) {
        transactionType = "income";
      } else if (capitalCategories.includes(input.category)) {
        transactionType = "capital";
      } else if (input.category === "transfer") {
        transactionType = "transfer";
      } else if (input.category === "personal") {
        transactionType = "personal";
      }

      const isDeductible = !nonDeductibleCategories.includes(input.category);

      await ctx.db
        .update(transactions)
        .set({
          category: input.category,
          transactionType,
          isDeductible,
          propertyId: input.propertyId,
          updatedAt: new Date(),
        })
        .where(
          and(
            inArray(transactions.id, input.ids),
            eq(transactions.userId, ctx.user.id)
          )
        );

      return { success: true, count: input.ids.length };
    }),

  toggleVerified: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      const existing = await ctx.db.query.transactions.findFirst({
        where: and(
          eq(transactions.id, input.id),
          eq(transactions.userId, ctx.user.id)
        ),
      });

      if (!existing) {
        throw new Error("Transaction not found");
      }

      const [transaction] = await ctx.db
        .update(transactions)
        .set({
          isVerified: !existing.isVerified,
          updatedAt: new Date(),
        })
        .where(eq(transactions.id, input.id))
        .returning();

      return transaction;
    }),

  updateNotes: protectedProcedure
    .input(z.object({ id: z.string().uuid(), notes: z.string() }))
    .mutation(async ({ ctx, input }) => {
      const [transaction] = await ctx.db
        .update(transactions)
        .set({
          notes: input.notes,
          updatedAt: new Date(),
        })
        .where(
          and(eq(transactions.id, input.id), eq(transactions.userId, ctx.user.id))
        )
        .returning();

      return transaction;
    }),
});
```

**Step 4: Create banking router (placeholder for now)**

Create `src/server/routers/banking.ts`:

```typescript
import { z } from "zod";
import { router, protectedProcedure } from "../trpc";
import { bankAccounts, transactions, properties } from "../db/schema";
import { eq, and } from "drizzle-orm";

export const bankingRouter = router({
  listAccounts: protectedProcedure.query(async ({ ctx }) => {
    return ctx.db.query.bankAccounts.findMany({
      where: eq(bankAccounts.userId, ctx.user.id),
      with: {
        defaultProperty: true,
      },
    });
  }),

  linkAccountToProperty: protectedProcedure
    .input(
      z.object({
        accountId: z.string().uuid(),
        propertyId: z.string().uuid().nullable(),
      })
    )
    .mutation(async ({ ctx, input }) => {
      const [account] = await ctx.db
        .update(bankAccounts)
        .set({
          defaultPropertyId: input.propertyId,
        })
        .where(
          and(
            eq(bankAccounts.id, input.accountId),
            eq(bankAccounts.userId, ctx.user.id)
          )
        )
        .returning();

      return account;
    }),

  // Placeholder - will be implemented with Basiq integration
  getConnectionUrl: protectedProcedure.query(async ({ ctx }) => {
    // TODO: Implement Basiq connection flow
    return {
      url: "https://connect.basiq.io/...",
      message: "Basiq integration coming soon",
    };
  }),
});
```

**Step 5: Create app router**

Create `src/server/routers/_app.ts`:

```typescript
import { router } from "../trpc";
import { propertyRouter } from "./property";
import { transactionRouter } from "./transaction";
import { bankingRouter } from "./banking";

export const appRouter = router({
  property: propertyRouter,
  transaction: transactionRouter,
  banking: bankingRouter,
});

export type AppRouter = typeof appRouter;
```

**Step 6: Create API route handler**

Create `src/app/api/trpc/[trpc]/route.ts`:

```typescript
import { fetchRequestHandler } from "@trpc/server/adapters/fetch";
import { appRouter } from "@/server/routers/_app";
import { createTRPCContext } from "@/server/trpc";

const handler = (req: Request) =>
  fetchRequestHandler({
    endpoint: "/api/trpc",
    req,
    router: appRouter,
    createContext: createTRPCContext,
  });

export { handler as GET, handler as POST };
```

**Step 7: Create tRPC client**

Create `src/lib/trpc/client.ts`:

```typescript
import { createTRPCReact } from "@trpc/react-query";
import type { AppRouter } from "@/server/routers/_app";

export const trpc = createTRPCReact<AppRouter>();
```

**Step 8: Create tRPC Provider**

Create `src/lib/trpc/Provider.tsx`:

```typescript
"use client";

import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { httpBatchLink } from "@trpc/client";
import { useState } from "react";
import { trpc } from "./client";

export function TRPCProvider({ children }: { children: React.ReactNode }) {
  const [queryClient] = useState(() => new QueryClient());
  const [trpcClient] = useState(() =>
    trpc.createClient({
      links: [
        httpBatchLink({
          url: "/api/trpc",
        }),
      ],
    })
  );

  return (
    <trpc.Provider client={trpcClient} queryClient={queryClient}>
      <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
    </trpc.Provider>
  );
}
```

**Step 9: Update root layout to include Provider**

Update `src/app/layout.tsx`:

```typescript
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import { ClerkProvider } from "@clerk/nextjs";
import { TRPCProvider } from "@/lib/trpc/Provider";
import "./globals.css";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "PropertyTracker - Australian Property Investment Tracking",
  description: "Track your investment properties, automate bank feeds, and generate tax reports.",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <ClerkProvider>
      <html lang="en">
        <body className={inter.className}>
          <TRPCProvider>{children}</TRPCProvider>
        </body>
      </html>
    </ClerkProvider>
  );
}
```

**Step 10: Commit**

```bash
git add -A
git commit -m "feat: setup tRPC with property, transaction, and banking routers"
```

---

## Phase 2: Core Features (Day 3-10)

### Task 8: Create Dashboard Layout

**Files:**
- Create: `src/app/(dashboard)/layout.tsx`
- Create: `src/app/(dashboard)/page.tsx`
- Create: `src/components/layout/Sidebar.tsx`
- Create: `src/components/layout/Header.tsx`

**Step 1: Create Sidebar component**

Create `src/components/layout/Sidebar.tsx`:

```typescript
"use client";

import Link from "next/link";
import { usePathname } from "next/navigation";
import { cn } from "@/lib/utils";
import {
  LayoutDashboard,
  Building2,
  ArrowLeftRight,
  Landmark,
  FileDown,
} from "lucide-react";

const navItems = [
  { href: "/dashboard", label: "Dashboard", icon: LayoutDashboard },
  { href: "/properties", label: "Properties", icon: Building2 },
  { href: "/transactions", label: "Transactions", icon: ArrowLeftRight },
  { href: "/banking", label: "Banking", icon: Landmark },
  { href: "/export", label: "Export", icon: FileDown },
];

export function Sidebar() {
  const pathname = usePathname();

  return (
    <aside className="w-64 border-r border-border bg-card min-h-screen p-4">
      <div className="mb-8">
        <Link href="/dashboard" className="flex items-center gap-2">
          <div className="w-8 h-8 rounded-lg bg-primary flex items-center justify-center">
            <Building2 className="w-5 h-5 text-primary-foreground" />
          </div>
          <span className="font-semibold text-lg">PropertyTracker</span>
        </Link>
      </div>

      <nav className="space-y-1">
        {navItems.map((item) => {
          const isActive = pathname === item.href;
          const Icon = item.icon;

          return (
            <Link
              key={item.href}
              href={item.href}
              className={cn(
                "flex items-center gap-3 px-3 py-2 rounded-md text-sm font-medium transition-colors",
                isActive
                  ? "bg-primary text-primary-foreground"
                  : "text-muted-foreground hover:bg-secondary hover:text-foreground"
              )}
            >
              <Icon className="w-5 h-5" />
              {item.label}
            </Link>
          );
        })}
      </nav>
    </aside>
  );
}
```

**Step 2: Create Header component**

Create `src/components/layout/Header.tsx`:

```typescript
"use client";

import { UserButton } from "@clerk/nextjs";

export function Header() {
  return (
    <header className="h-16 border-b border-border bg-card px-6 flex items-center justify-between">
      <div>
        <h1 className="text-lg font-semibold">Dashboard</h1>
      </div>
      <div className="flex items-center gap-4">
        <UserButton afterSignOutUrl="/" />
      </div>
    </header>
  );
}
```

**Step 3: Create dashboard layout**

Create `src/app/(dashboard)/layout.tsx`:

```typescript
import { Sidebar } from "@/components/layout/Sidebar";
import { Header } from "@/components/layout/Header";

export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <div className="flex min-h-screen">
      <Sidebar />
      <div className="flex-1 flex flex-col">
        <Header />
        <main className="flex-1 p-6 bg-secondary">{children}</main>
      </div>
    </div>
  );
}
```

**Step 4: Create dashboard page**

Create `src/app/(dashboard)/page.tsx`:

```typescript
import { redirect } from "next/navigation";

export default function DashboardRedirect() {
  redirect("/dashboard");
}
```

Create `src/app/(dashboard)/dashboard/page.tsx`:

```typescript
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Building2, ArrowLeftRight, AlertCircle } from "lucide-react";

export default function DashboardPage() {
  return (
    <div className="space-y-6">
      <div>
        <h2 className="text-2xl font-bold">Welcome to PropertyTracker</h2>
        <p className="text-muted-foreground">
          Track your investment properties, automate bank feeds, and generate tax reports.
        </p>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
        <Card>
          <CardHeader className="flex flex-row items-center justify-between pb-2">
            <CardTitle className="text-sm font-medium">Properties</CardTitle>
            <Building2 className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">0</div>
            <p className="text-xs text-muted-foreground">
              Add your first property to get started
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between pb-2">
            <CardTitle className="text-sm font-medium">Transactions</CardTitle>
            <ArrowLeftRight className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">0</div>
            <p className="text-xs text-muted-foreground">
              Connect your bank to import transactions
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between pb-2">
            <CardTitle className="text-sm font-medium">
              Uncategorized
            </CardTitle>
            <AlertCircle className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">0</div>
            <p className="text-xs text-muted-foreground">
              Transactions needing review
            </p>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}
```

**Step 5: Commit**

```bash
git add -A
git commit -m "feat: add dashboard layout with sidebar navigation"
```

---

## Phase 2 Continued: Remaining Tasks

Due to the length of this plan, the remaining tasks are outlined below. Each follows the same TDD pattern.

### Task 9: Properties List & Create Form
- Create `src/app/(dashboard)/properties/page.tsx` - List view with cards
- Create `src/app/(dashboard)/properties/new/page.tsx` - Create form
- Create `src/components/properties/PropertyCard.tsx`
- Create `src/components/properties/PropertyForm.tsx`

### Task 10: Transactions List View
- Create `src/app/(dashboard)/transactions/page.tsx`
- Create `src/components/transactions/TransactionTable.tsx`
- Create `src/components/transactions/CategorySelect.tsx`
- Create `src/components/transactions/TransactionFilters.tsx`

### Task 11: Banking Connection (Basiq)
- Create `src/server/services/basiq.ts` - Basiq API wrapper
- Create `src/app/(dashboard)/banking/page.tsx` - Connected accounts list
- Create `src/app/(dashboard)/banking/connect/page.tsx` - Connection flow
- Create `src/app/api/webhooks/basiq/route.ts` - Webhook handler

### Task 12: CSV Export
- Create `src/app/(dashboard)/export/page.tsx` - Export configuration
- Create `src/server/services/export.ts` - CSV generation
- Create `src/app/api/export/csv/route.ts` - Download endpoint

### Task 13: ATO Categories Helper
- Create `src/lib/categories.ts` - Category definitions with metadata
- Update transaction categorization to use helper

### Task 14: Clerk Webhook for User Sync
- Create `src/app/api/webhooks/clerk/route.ts`
- Sync Clerk users to local database

---

## Phase 3: Testing & Polish (Day 11-14)

### Task 15: Add E2E Tests
- Setup Playwright
- Test auth flow
- Test property CRUD
- Test transaction categorization
- Test CSV export

### Task 16: Error Handling & Loading States
- Add loading skeletons
- Add error boundaries
- Add toast notifications

### Task 17: Final Polish
- Responsive design fixes
- Accessibility audit
- Performance optimization

---

## Deployment Checklist

### Before Deploying v0.1:

- [ ] Environment variables set in Vercel
- [ ] Supabase database created and migrated
- [ ] Clerk application configured
- [ ] Basiq sandbox credentials
- [ ] Domain configured
- [ ] Error tracking (Sentry) enabled

### Commands:

```bash
# Push database schema
npm run db:push

# Build and check for errors
npm run build

# Deploy to Vercel
vercel --prod
```

---

## Success Criteria Checklist

- [ ] Shipped in 4 weeks
- [ ] 10 users connect bank accounts
- [ ] 5 users generate export
- [ ] 2 accountants review export and say "usable"
- [ ] <3 critical bugs reported

---

**Plan complete and saved to `docs/plans/2026-01-23-v0.1-implementation-plan.md`.**

**Two execution options:**

1. **Subagent-Driven (this session)** - I dispatch fresh subagent per task, review between tasks, fast iteration

2. **Parallel Session (separate)** - Open new session in worktree with executing-plans, batch execution with checkpoints

**Which approach?**